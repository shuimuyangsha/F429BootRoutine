/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug 18 2014, 17:12:05                              *
*        (c) 2014 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/
#include "includes.h"
#include  "app.h"
// USER START (Optionally insert additional includes)
// USER END

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
// USER START (Optionally insert additional defines)
/*--------------------  (使用U2C.exe小工具生成)  ------------------------------------*/
/*
*  U2C.exe小工具使用方法：新建一个TXT文本文件，输入待转换文本，另存为UTF8编码格式文件，
*  打开U2C.exe小工具，先导入文件文件，然后选择"Convert"进行转换，完成后在同路径下输出
*  同名.c文件。
*/
#define UTF8_RGBLEDDLG     "RGB\xe5\xbd\xa9\xe7\x81\xaf"  //RGB彩灯
#define UTF8_ADCONVER      "AD\xe8\xbd\xac\xe6\x8d\xa2"   //AD转换
#define UTF8_ADRESULT      "AD\xe8\xbd\xac\xe6\x8d\xa2\xe7\xbb\x93\xe6\x9e\x9c:"     //AD转换结果
#define UTF8_VOLTAGE       "\xe7\x94\xb5\xe5\x8e\x8b\xe5\x80\xbc:"//电压值
/*-----------------------------------------------------------------------------------*/

#define PWM_LEDR_GPIO_PORT         GPIOH
#define PWM_LEDR_GPIO_PIN          GPIO_Pin_10
#define PWM_LEDR_GPIO_CLK          RCC_AHB1Periph_GPIOH
#define PWM_LEDR_PINSOURCE         GPIO_PinSource10
#define PWM_LEDR_AF                GPIO_AF_TIM5

#define PWM_LEDG_GPIO_PORT         GPIOH
#define PWM_LEDG_GPIO_PIN          GPIO_Pin_11
#define PWM_LEDG_GPIO_CLK          RCC_AHB1Periph_GPIOH
#define PWM_LEDG_PINSOURCE         GPIO_PinSource11
#define PWM_LEDG_AF                GPIO_AF_TIM5

#define PWM_LEDB_GPIO_PORT         GPIOH
#define PWM_LEDB_GPIO_PIN          GPIO_Pin_12
#define PWM_LEDB_GPIO_CLK          RCC_AHB1Periph_GPIOH
#define PWM_LEDB_PINSOURCE         GPIO_PinSource12
#define PWM_LEDB_AF                GPIO_AF_TIM5

#define PWM_LEDRGB_TIM             TIM5
#define PWM_LEDRGB_TIM_CLK         RCC_APB1Periph_TIM5

#define ADC_GPIO_PORT    GPIOC
#define ADC_GPIO_PIN     GPIO_Pin_3
#define ADC_GPIO_CLK     RCC_AHB1Periph_GPIOC
#define ADCn             ADC1
#define ADC_CLK          RCC_APB2Periph_ADC1
#define ADC_CHANNEL      ADC_Channel_13
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
// USER START (Optionally insert additional static data)
static uint8_t  rValue,gValue,bValue;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreateRGBLED[] = {
  { FRAMEWIN_CreateIndirect, "RGBLED",  0,              0,   0,   800, 480, 0, 0x0, 0 },
  { SLIDER_CreateIndirect,   "rSlider", GUI_ID_SLIDER0, 250, 50,  250, 40,  0, 0x0, 0 },
  { SLIDER_CreateIndirect,   "gSlider", GUI_ID_SLIDER1, 250, 130, 250, 40,  0, 0x0, 0 },
  { SLIDER_CreateIndirect,   "bSlider", GUI_ID_SLIDER2, 250, 210, 250, 40,  0, 0x0, 0 },
  { EDIT_CreateIndirect,     "rEdit",   GUI_ID_EDIT0,   175, 55,  60,  30,  0, 0x3, 0 },
  { EDIT_CreateIndirect,     "gEdit",   GUI_ID_EDIT1,   175, 135, 60,  30,  0, 0x3, 0 },
  { EDIT_CreateIndirect,     "bEdit",   GUI_ID_EDIT2,   175, 215, 60,  30,  0, 0x3, 0 },  
  { TEXT_CreateIndirect,     "ADValue", GUI_ID_TEXT0,   260, 355, 100, 35,  0, 0x64,0 },
  { TEXT_CreateIndirect,     "Voltage", GUI_ID_TEXT1,   550, 355, 80,  35,  0, 0x64,0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
// USER START (Optionally insert additional static code)
 /**
  * @brief  配置TIM3复用输出PWM时用到的I/O
  * @param  无
  * @retval 无
  */
static void TIM_GPIO_Config(void) 
{
  GPIO_InitTypeDef GPIO_InitStructure;

  /* GPIOB clock enable */
  RCC_AHB1PeriphClockCmd(PWM_LEDR_GPIO_CLK|PWM_LEDG_GPIO_CLK|PWM_LEDB_GPIO_CLK, ENABLE); 
  
  GPIO_PinAFConfig(PWM_LEDR_GPIO_PORT,PWM_LEDR_PINSOURCE,PWM_LEDR_AF); 
  GPIO_PinAFConfig(PWM_LEDG_GPIO_PORT,PWM_LEDG_PINSOURCE,PWM_LEDG_AF); 
  GPIO_PinAFConfig(PWM_LEDB_GPIO_PORT,PWM_LEDB_PINSOURCE,PWM_LEDB_AF); 
  
  /* 配置呼吸灯用到的PB0引脚 */
  GPIO_InitStructure.GPIO_Pin =  PWM_LEDR_GPIO_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;		    // 复用推挽输出
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;      //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;   //100MHz
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL; 
  GPIO_Init(PWM_LEDR_GPIO_PORT, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin =  PWM_LEDG_GPIO_PIN;
  GPIO_Init(PWM_LEDG_GPIO_PORT, &GPIO_InitStructure);
  
  GPIO_InitStructure.GPIO_Pin =  PWM_LEDB_GPIO_PIN;
  GPIO_Init(PWM_LEDB_GPIO_PORT, &GPIO_InitStructure);
}

/**
  * @brief  配置TIM3输出的PWM信号的模式，如周期、极性
  * @param  无
  * @retval 无
  */
/*
 * TIMxCLK/CK_PSC --> TIMxCNT --> TIMx_ARR --> 中断 & TIMxCNT 重新计数
 *                    TIMx_CCR(电平发生变化)
 *
 * 信号周期=(TIMx_ARR +1 ) * 时钟周期
 * 
 */
/*    _______    ______     _____      ____       ___        __         _
 * |_|       |__|      |___|     |____|    |_____|   |______|  |_______| |________|
 */
static void TIM_Mode_Config(void)
{
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	TIM_OCInitTypeDef  TIM_OCInitStructure;																				
	
	/* 设置TIM3CLK 时钟为72MHZ */
  RCC_APB1PeriphClockCmd(PWM_LEDRGB_TIM_CLK, ENABLE); 					//使能TIM5时钟

  /* 基本定时器配置 */		 
  TIM_TimeBaseStructure.TIM_Period = 255;       							  //当定时器从0计数到255，即为266次，为一个定时周期
  TIM_TimeBaseStructure.TIM_Prescaler = 2499;	    							//设置预分频：
  TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1 ;			//设置时钟分频系数：不分频(这里用不到)
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  	//向上计数模式
  TIM_TimeBaseInit(PWM_LEDRGB_TIM, &TIM_TimeBaseStructure);

  /* PWM模式配置 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;	    				//配置为PWM模式1
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;	//使能输出
  TIM_OCInitStructure.TIM_Pulse = 0;										  			//设置初始PWM脉冲宽度为0	
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;  	  //当定时器计数值小于CCR1_Val时为低电平

  TIM_OC1Init(PWM_LEDRGB_TIM, &TIM_OCInitStructure);	 									//使能通道3
  TIM_OC1PreloadConfig(PWM_LEDRGB_TIM, TIM_OCPreload_Enable);						//使能预装载	

  TIM_OC2Init(PWM_LEDRGB_TIM, &TIM_OCInitStructure);	 									//使能通道3
  TIM_OC2PreloadConfig(PWM_LEDRGB_TIM, TIM_OCPreload_Enable);						//使能预装载	
  
  TIM_OC3Init(PWM_LEDRGB_TIM, &TIM_OCInitStructure);	 									//使能通道3
  TIM_OC3PreloadConfig(PWM_LEDRGB_TIM, TIM_OCPreload_Enable);						//使能预装载	
  
  TIM_ARRPreloadConfig(PWM_LEDRGB_TIM, ENABLE);			 										//使能TIM5重载寄存器ARR

  /* TIM5 enable counter */
  TIM_Cmd(PWM_LEDRGB_TIM, ENABLE);                   										//使能定时器5
	
}

//RGBLED显示颜色
void SetRGBColor(uint32_t rgb)
{
	uint8_t r=0,g=0,b=0;
	r=(uint8_t)(rgb>>16);
	g=(uint8_t)(rgb>>8);
	b=(uint8_t)rgb;
	PWM_LEDRGB_TIM->CCR1 = r;	//根据PWM表修改定时器的比较寄存器值
	PWM_LEDRGB_TIM->CCR2 = g;	//根据PWM表修改定时器的比较寄存器值        
	PWM_LEDRGB_TIM->CCR3 = b;	//根据PWM表修改定时器的比较寄存器值
}

//RGBLED显示颜色
void SetColorValue(uint8_t r,uint8_t g,uint8_t b)
{
	PWM_LEDRGB_TIM->CCR1 = r;	//根据PWM表修改定时器的比较寄存器值
	PWM_LEDRGB_TIM->CCR2 = g;	//根据PWM表修改定时器的比较寄存器值        
	PWM_LEDRGB_TIM->CCR3 = b;	//根据PWM表修改定时器的比较寄存器值
}

//停止pwm输出
void TIM_RGBLED_Close(void)
{
	SetColorValue(0,0,0);
	TIM_ForcedOC1Config(PWM_LEDRGB_TIM,TIM_ForcedAction_InActive);
	TIM_ForcedOC2Config(PWM_LEDRGB_TIM,TIM_ForcedAction_InActive);
	TIM_ForcedOC3Config(PWM_LEDRGB_TIM,TIM_ForcedAction_InActive);
	TIM_ARRPreloadConfig(PWM_LEDRGB_TIM, DISABLE);
	TIM_Cmd(PWM_LEDRGB_TIM, DISABLE);                   							//失能定时器3						
	RCC_APB1PeriphClockCmd(PWM_LEDRGB_TIM_CLK, DISABLE); 	//失能定时器3时钟
	LED_GPIO_Config();
}

/**
  * @brief  Configures the ADC.
  * @param  None
  * @retval None
  */
static void ADC_Configuration(void)
{
  ADC_InitTypeDef ADC_InitStructure;
  ADC_CommonInitTypeDef ADC_CommonInitStructure;
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable ADC1 clock */
  RCC_APB2PeriphClockCmd(ADC_CLK, ENABLE);

  /* Configure ADC Channel 12 as analog input */
  GPIO_InitStructure.GPIO_Pin = ADC_GPIO_PIN;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;//不上拉不下拉
  GPIO_Init(ADC_GPIO_PORT, &GPIO_InitStructure);

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;// 独立ADC模式
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;// 时钟为fpclk x分频	
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;// 禁止DMA直接访问模式	
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_10Cycles; // 采样时间间隔	
  ADC_CommonInit(&ADC_CommonInitStructure); 

  /* ADC1 Configuration ------------------------------------------------------*/
  ADC_StructInit(&ADC_InitStructure);
  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;// ADC 分辨率
  ADC_InitStructure.ADC_ScanConvMode = DISABLE;// 禁止扫描模式，多通道采集才需要	
  ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;// 连续转换	
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None; //禁止外部边沿触发
//	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;	//使用软件触发，外部触发不用配置，注释掉即可
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//数据右对齐
  ADC_InitStructure.ADC_NbrOfConversion = 1;//转换通道 1个
  ADC_Init(ADCn, &ADC_InitStructure);

  /* ADC1 Regular Channel Config */
  // 配置 ADC 通道转换顺序为1，第一个转换，采样时间为56个时钟周期
  ADC_RegularChannelConfig(ADCn, ADC_CHANNEL, 1, ADC_SampleTime_56Cycles);

  /* Enable ADC1 */
  ADC_Cmd(ADCn, ENABLE);// 使能ADC

  /* ADC1 regular Software Start Conv */ 
  ADC_SoftwareStartConv(ADCn);//开始adc转换，软件触发
}
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialogRGBLED(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  char tempstr[50];
  // USER END

  switch (pMsg->MsgId) {
	case WM_DELETE:
		// USER START (Optionally insert additional code for further widget initialization)
		OS_INFO("RGBLEDDLG delete\n");
		TIM_RGBLED_Close();		
		Flag_ICON0 = 0;
		UserApp_Flag = 0;
    tpad_flag=0;
		WM_DeleteWindow(hkeypad);
    ADC_Cmd(ADCn, DISABLE);
		// USER END
	break;
  case WM_INIT_DIALOG:
    //
    // Initialization of 'RGBLED'
    //
		hItem = pMsg->hWin;
    sprintf(tempstr,"%s&%s",UTF8_RGBLEDDLG,UTF8_ADCONVER);
		FRAMEWIN_SetText(hItem,tempstr);
		FRAMEWIN_AddCloseButton(hItem,FRAMEWIN_BUTTON_RIGHT,0);
    //
    // Initialization of 'rEdit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0);
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
		EDIT_SetUlongMode(hItem,rValue,0,255);		
    EDIT_EnableBlink(hItem,250,1);
    //
    // Initialization of 'gEdit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1);
    EDIT_SetUlongMode(hItem,gValue,0,255);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_EnableBlink(hItem,250,1);
    //
    // Initialization of 'bEdit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2);
    EDIT_SetUlongMode(hItem,bValue,0,255);
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_EnableBlink(hItem,250,1);
		//
		// Initialization of 'rSlider'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER0);
		SLIDER_SetRange(hItem,0,255);
		SLIDER_SetValue(hItem,rValue);
		//
		// Initialization of 'gSlider'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER1);
		SLIDER_SetRange(hItem,0,255);
		SLIDER_SetValue(hItem,gValue);
		//
		// Initialization of 'bSlider'
		//
		hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER2);
		SLIDER_SetRange(hItem,0,255);
		SLIDER_SetValue(hItem,bValue);
    //
    // Initialization of 'ADValue'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT0);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
    TEXT_SetTextColor(hItem, GUI_BLACK);
    TEXT_SetBkColor(hItem, GUI_WHITE);
    TEXT_SetText(hItem, "0x0000");
    //
    // Initialization of 'Voltage'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_TEXT1);
    TEXT_SetFont(hItem, GUI_FONT_32B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
    TEXT_SetTextColor(hItem, GUI_BLACK);
    TEXT_SetBkColor(hItem, GUI_WHITE);
    TEXT_SetText(hItem, "0");
    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case GUI_ID_SLIDER0: // Notifications sent by 'rSlider'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        rValue=SLIDER_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER0));
				EDIT_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0),rValue);
				SetColorValue(rValue,gValue,bValue);
				WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_SLIDER1: // Notifications sent by 'gSlider'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        gValue=SLIDER_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER1));
				EDIT_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1),gValue);
				SetColorValue(rValue,gValue,bValue);
				WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_SLIDER2: // Notifications sent by 'bSlider'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        bValue=SLIDER_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER2));
				EDIT_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2),bValue);
				SetColorValue(rValue,gValue,bValue);
				WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT0: // Notifications sent by 'rEdit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				KeyPad_Interface(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0),0);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				rValue=EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT0));
				SLIDER_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER0),rValue);
				SetColorValue(rValue,gValue,bValue);
        WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT1: // Notifications sent by 'gEdit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				KeyPad_Interface(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1),0);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				gValue=EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT1));
				SLIDER_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER1),gValue);
				SetColorValue(rValue,gValue,bValue);
        WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case GUI_ID_EDIT2: // Notifications sent by 'bEdit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
				KeyPad_Interface(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2),0);
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
				bValue=EDIT_GetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_EDIT2));
				SLIDER_SetValue(WM_GetDialogItem(pMsg->hWin, GUI_ID_SLIDER2),bValue);
				SetColorValue(rValue,gValue,bValue);
        WM_InvalidateWindow(pMsg->hWin);
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
	case WM_PAINT:
    GUI_SetPenSize( 2 );
    GUI_SetColor(GUI_BLUE);  
    GUI_DrawRect(80,20,720,280);
    GUI_DrawRect(80,310,720,420);
    GUI_SetFont(&XBF_XINSONGTI25);
    GUI_SetColor(GUI_LIGHTBLUE);    
    GUI_DispStringHCenterAt(UTF8_RGBLEDDLG, 375,10);
    GUI_DispStringHCenterAt(UTF8_ADCONVER,375,300);
    
    GUI_SetColor(GUI_LIGHTGREEN);
    GUI_DispStringAt(UTF8_ADRESULT,110,360);
    GUI_DispStringAt(UTF8_VOLTAGE,450,360);
    GUI_DispStringAt("V",635,360);
		//
		// Draw RGB values
		//
		GUI_SetColor((U32)rValue);
		GUI_FillRect(110, 40, 170, 100);
		GUI_SetColor(((U32)gValue) << 8);
		GUI_FillRect(110,120, 170, 180);
		GUI_SetColor(((U32)bValue) << 16);
		GUI_FillRect(110,200, 170, 260);
		//
		// Draw resulting color
		//
		GUI_SetColor(rValue | (((U32)gValue) << 8) | (((U32)bValue) << 16));
		GUI_FillCircle(615,150,75);
		break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateRGBLED
*/
void FUN_ICON0Clicked(void)
{
  uint8_t timecount=0;
  WM_HWIN hWin;
  uint32_t ADCVal = 0;
  float ADVoltage=0;
  char str[10]={0};
	rValue=218;
	gValue=37;
	bValue=196;
	OS_INFO("RGBLEDDLG create\n");
  
  TIM_GPIO_Config();
  TIM_Mode_Config();
  
	SetColorValue(rValue,gValue,bValue);
  
  hWin=GUI_CreateDialogBox(_aDialogCreateRGBLED, GUI_COUNTOF(_aDialogCreateRGBLED), _cbDialogRGBLED, HDTWIN, 0, 0);
	ADC_Configuration();
  while(Flag_ICON0)
	{	
    if(timecount==50)
    {
      ADCVal=ADC_GetConversionValue(ADC1);
      sprintf(str,"0x%04x",ADCVal);
      TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT0),str);
      ADVoltage = ADCVal*3.3/4096;
      sprintf(str,"%0.3f",ADVoltage);
      TEXT_SetText(WM_GetDialogItem(hWin, GUI_ID_TEXT1),str);
      timecount=0;
    }
    timecount++;
    if(tpad_flag)WM_DeleteWindow(hWin);     
		GUI_Delay(10); 				
	}
	
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
